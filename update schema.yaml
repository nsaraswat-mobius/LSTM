name: Update Schema with Prediction
description: Updates a schema instance with the LSTM model prediction output.
inputs:
  - {name: schema_id, type: String, description: 'Schema ID to update'}
  - {name: execution_id, type: String, description: 'Execution ID for filtering instances'}
  - {name: prediction_json, type: Dataset, description: 'Prediction output from LSTM inference'}
  - {name: token, type: Dataset, description: 'Access token file'}
  - {name: url_domain, type: String, description: 'API domain URL'}
outputs:
  - {name: status_output, type: Dataset, description: 'Update status confirmation'}
implementation:
  container:
    image: python:3.9
    command:
      - sh
      - -ec
      - |
        python3 -m pip install --quiet requests || \
        python3 -m pip install --quiet requests --user
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import argparse
        import json
        import requests
        import os

        def update_instance(access_token, domain, schema_id, execution_id, updates):
            update_url = f"https://{domain}/pi-entity-instances-service/v2.0/schemas/{schema_id}/instances"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
            patch_operations = [
                {"operation": "REPLACE", "path": field, "value": value}
                for field, value in updates.items()
            ]
            payload = {
                "dbType": "TIDB",
                "conditionalFilter": {
                    "conditions": [
                        {
                            "field": "execution_id", 
                            "operator": "EQUAL", 
                            "value": execution_id
                        }
                    ]
                },
                "partialUpdateRequests": [
                    {
                        "patch": patch_operations
                    }
                ]
            }
            print(f"Update URL: {update_url}")
            print(f"Update payload: {json.dumps(payload, indent=2)}")
            response = requests.patch(update_url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()
            return response.json()

        def main():
            parser = argparse.ArgumentParser()
            parser.add_argument('--schema_id', type=str, required=True)
            parser.add_argument('--execution_id', type=str, required=True)
            parser.add_argument('--prediction_json', type=str, required=True)
            parser.add_argument('--token', type=str, required=True)
            parser.add_argument('--url_domain', type=str, required=True)
            parser.add_argument('--status_output', type=str, required=True)
            args = parser.parse_args()

            # Read access token
            print("Reading access token...")
            with open(args.token, 'r') as f:
                access_token = f.read().strip()

            # Load prediction data from LSTM inference
            print(f"Loading prediction data from: {args.prediction_json}")
            with open(args.prediction_json, 'r') as f:
                prediction_data = json.load(f)
            
            print(f"Raw prediction data: {json.dumps(prediction_data, indent=2)}")
            
            # Extract prediction - handle nested list structure from LSTM output
            prediction_output = prediction_data.get('prediction', [])
            
            # Flatten the prediction if it's nested
            if isinstance(prediction_output, list) and len(prediction_output) > 0:
                if isinstance(prediction_output[0], list):
                    # Handle case where prediction is [[-0.29382383823394775]]
                    prediction_output = prediction_output[0]
            
            # Convert to string representation
            if isinstance(prediction_output, list):
                prediction_str = json.dumps(prediction_output)
            else:
                prediction_str = str(prediction_output)
            
            print(f"Final prediction string: {prediction_str}")

            # Prepare update payload
            update_payload = {
                "inference_output": prediction_str,
                "prediction_status": "completed"
            }
            
            # Update schema instance
            print(f"Updating instance for execution_id: {args.execution_id}")
            try:
                result = update_instance(
                    access_token, 
                    args.url_domain, 
                    args.schema_id, 
                    args.execution_id, 
                    update_payload
                )
                print(f"Update successful: {json.dumps(result, indent=2)}")
                
                # Prepare status output
                status_result = {
                    "status": "success",
                    "execution_id": args.execution_id,
                    "prediction": prediction_str,
                    "update_timestamp": "completed"
                }
                
            except Exception as e:
                print(f"Update failed: {str(e)}")
                status_result = {
                    "status": "error",
                    "execution_id": args.execution_id,
                    "error": str(e),
                    "update_timestamp": "failed"
                }
                raise

            # Save status output - try multiple paths for compatibility
            output_paths = [
                args.status_output,
                '/tmp/outputs/status_output/data',
                '/tmp/outputs/status/data',
                '/tmp/status_output.json'
            ]
            
            saved = False
            for path in output_paths:
                try:
                    output_dir = os.path.dirname(path)
                    if output_dir and not os.path.exists(output_dir):
                        os.makedirs(output_dir, exist_ok=True)
                    
                    with open(path, 'w') as f:
                        json.dump(status_result, f, indent=2)
                    
                    print(f"Saved status output to: {path}")
                    saved = True
                    break
                except Exception as e:
                    print(f"Failed to save to {path}: {e}")
            
            if not saved:
                print("Could not save status output - printing result:")
                print(json.dumps(status_result, indent=2))

        if __name__ == '__main__':
            main()
    args:
      - --schema_id
      - {inputValue: schema_id}
      - --execution_id
      - {inputValue: execution_id}
      - --prediction_json
      - {inputPath: prediction_json}
      - --token
      - {inputPath: token}
      - --url_domain
      - {inputValue: url_domain}
      - --status_output
      - {outputPath: status_output}
