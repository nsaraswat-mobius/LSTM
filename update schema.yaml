name: Update Schema with LSTM Prediction
description: Updates a schema instance with LSTM inference prediction output.
inputs:
  - {name: schema_id, type: String}
  - {name: execution_id, type: String}
  - {name: output_json, type: String}
  - {name: token, type: String}
  - {name: url_domain, type: String}
implementation:
  container:
    image: python:3.9
    command:
      - sh
      - -ec
      - |
        python3 -m pip install --quiet requests || \
        python3 -m pip install --quiet requests --user
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import argparse
        import json
        import requests
        import os

        def update_instance(access_token, domain, schema_id, execution_id, updates):
            update_url = f"https://{domain}/pi-entity-instances-service/v2.0/schemas/{schema_id}/instances"
            headers = {
                "Authorization": f"Bearer {access_token}", 
                "Content-Type": "application/json"
            }
            patch_operations = [
                {"operation": "REPLACE", "path": field, "value": value}
                for field, value in updates.items()
            ]
            payload = {
                "dbType": "TIDB",
                "conditionalFilter": {"conditions": [{"field": "execution_id", "operator": "EQUAL", "value": execution_id}]},
                "partialUpdateRequests": [{"patch": patch_operations}]
            }
            print(f"Update payload: {json.dumps(payload, indent=2)}")
            response = requests.patch(update_url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()
            return response.json()

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--output_json', type=str, required=True)
        parser.add_argument('--token', type=str, required=True)
        parser.add_argument('--url_domain', type=str, required=True)
        args = parser.parse_args()

        # Read token
        with open(args.token, 'r') as f:
            access_token = f.read().strip()

        # Read the LSTM inference output - handle multiple possible paths
        prediction_data = None
        possible_paths = [
            args.output_json,
            '/tmp/outputs/output_json/data',
            '/tmp/outputs/output/data', 
            '/tmp/output.json'
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                try:
                    with open(path, 'r') as f:
                        prediction_data = json.load(f)
                    print(f"Successfully loaded prediction data from: {path}")
                    break
                except Exception as e:
                    print(f"Failed to load from {path}: {e}")
        
        if prediction_data is None:
            raise FileNotFoundError(f"Could not find prediction output file in any of: {possible_paths}")

        # Extract prediction and convert to string for storage
        prediction_list = prediction_data.get('prediction', [])
        print(f"Raw prediction data: {prediction_data}")
        print(f"Extracted prediction: {prediction_list}")
        
        # Flatten the prediction if it's nested (common in LSTM outputs)
        if prediction_list and isinstance(prediction_list[0], list):
            prediction_list = [item for sublist in prediction_list for item in sublist]
            print(f"Flattened prediction: {prediction_list}")
        
        prediction_str = json.dumps(prediction_list)

        # Prepare update payload
        update_payload = {"infernce_output": prediction_str}
        
        print(f"Updating instance for execution_id {args.execution_id}")
        result = update_instance(access_token, args.url_domain, args.schema_id, args.execution_id, update_payload)
        print(f"Instance for execution_id {args.execution_id} updated successfully.")
        print(f"Update response: {json.dumps(result, indent=2)}")

    args:
      - --schema_id
      - {inputValue: schema_id}
      - --execution_id
      - {inputValue: execution_id}
      - --output_json
      - {inputPath: output_json}
      - --token
      - {inputPath: token}
      - --url_domain
      - {inputValue: url_domain}
