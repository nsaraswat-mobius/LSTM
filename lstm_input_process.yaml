implementation:
  container:
    image: python:3.9
    command:
      - sh
      - -c
      - |
        PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet requests || \
        PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet requests --user
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import argparse
        import json
        import os
        import requests
        import pickle
        import ast

        def fetch_data_from_api(schema_id, execution_id, token, url_domain):
            url = f'https://{url_domain}/pi-entity-instances-service/v3.0/schemas/{schema_id}/instances/list'
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {token}'
            }
            data = {
              "dbType": "TIDB",
              "ownedOnly": False,
              "filter": {
                  "execution_id": execution_id
              }
            }
            response = requests.post(url, headers=headers, data=json.dumps(data))
            response.raise_for_status()
            return response.json()

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--token', type=str, required=True)
        parser.add_argument('--url_domain', type=str, required=True)
        parser.add_argument('--out_pickle', type=str, required=True)
        args = parser.parse_args()
        
        with open(args.token, 'r') as f:
            token = f.read().strip()

        print(f"Fetching data")
        data = fetch_data_from_api(args.schema_id, args.execution_id, token, args.url_domain)
        print(f"API Response received")
        
        # Safely extract inference input with better error handling
        content_list = data.get('content', [])
        if not content_list:
            raise ValueError("No content found in API response")
        
        inference_input_str = content_list[0].get('infernce_input', '[]')
        print(f"Raw inference input string length: {len(inference_input_str)}")
        
        def safe_parse_array(data_str):
            data_str = data_str.strip()
            
            # Method 1: Try ast.literal_eval first
            try:
                result = ast.literal_eval(data_str)
                print("Successfully parsed using ast.literal_eval")
                return result
            except (SyntaxError, ValueError) as e:
                print(f"ast.literal_eval failed: {e}")
            
            # Method 2: Try JSON parsing
            try:
                result = json.loads(data_str)
                print("Successfully parsed using JSON")
                return result
            except json.JSONDecodeError as e:
                print(f"JSON parsing failed: {e}")
            
            # Method 3: Fix bracket issues and try again
            try:
                # Count brackets and fix imbalance
                open_brackets = data_str.count('[')
                close_brackets = data_str.count(']')
                if close_brackets < open_brackets:
                    data_str += ']' * (open_brackets - close_brackets)
                elif close_brackets > open_brackets:
                    data_str = data_str.rstrip(']')  # Remove extra closing brackets
                
                result = ast.literal_eval(data_str)
                print("Successfully parsed after bracket fixing")
                return result
            except (SyntaxError, ValueError) as e:
                print(f"Fixed bracket parsing failed: {e}")
            
            # Method 4: Last resort - manual parsing for simple cases
            try:
                # Remove outer brackets and split
                clean_str = data_str.strip('[]')
                arrays = clean_str.split('],[')
                result = []
                for arr_str in arrays:
                    # Clean up each array string
                    arr_str = arr_str.replace('[', '').replace(']', '')
                    numbers = [float(x.strip()) for x in arr_str.split(',')]
                    result.append(numbers)
                print("Successfully parsed using manual method")
                return result
            except Exception as e:
                print(f"Manual parsing failed: {e}")
                raise ValueError(f"Could not parse inference input: {data_str}")

        # Convert the string representation of the list to an actual list
        inference_input = safe_parse_array(inference_input_str)
        print(f"Successfully parsed inference input with shape: {len(inference_input)} sequences")
        
        os.makedirs(os.path.dirname(args.out_pickle), exist_ok=True)
        with open(args.out_pickle, "wb") as f:
            pickle.dump(inference_input, f)

        print(f"Saved pickled data to {args.out_pickle}")
    args:
      - --schema_id
      - {inputValue: schema_id}
      - --execution_id
      - {inputValue: execution_id}
      - --token
      - {inputPath: token}
      - --url_domain
      - {inputValue: url_domain}
      - --out_pickle
      - {outputPath: out_pickle}
